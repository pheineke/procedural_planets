/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/simplex-noise@4.0.3/dist/cjs/simplex-noise.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.buildPermutationTable = exports.createNoise4D = exports.createNoise3D = exports.createNoise2D = void 0; const SQRT3 = Math.sqrt(3), SQRT5 = Math.sqrt(5), F2 = .5 * (SQRT3 - 1), G2 = (3 - SQRT3) / 6, F3 = 1 / 3, G3 = 1 / 6, F4 = (SQRT5 - 1) / 4, G4 = (5 - SQRT5) / 20, fastFloor = t => 0 | Math.floor(t), grad2 = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]), grad3 = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]), grad4 = new Float64Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]); function createNoise2D(t = Math.random) { const e = buildPermutationTable(t), o = new Float64Array(e).map((t => grad2[t % 12 * 2])), r = new Float64Array(e).map((t => grad2[t % 12 * 2 + 1])); return function (t, a) { let n = 0, l = 0, s = 0; const i = (t + a) * F2, c = fastFloor(t + i), f = fastFloor(a + i), G = (c + f) * G2, u = t - (c - G), F = a - (f - G); let d, m; u > F ? (d = 1, m = 0) : (d = 0, m = 1); const p = u - d + G2, b = F - m + G2, y = u - 1 + 2 * G2, w = F - 1 + 2 * G2, A = 255 & c, T = 255 & f; let g = .5 - u * u - F * F; if (g >= 0) { const t = A + e[T]; g *= g, n = g * g * (o[t] * u + r[t] * F) } let D = .5 - p * p - b * b; if (D >= 0) { const t = A + d + e[T + m]; D *= D, l = D * D * (o[t] * p + r[t] * b) } let N = .5 - y * y - w * w; if (N >= 0) { const t = A + 1 + e[T + 1]; N *= N, s = N * N * (o[t] * y + r[t] * w) } return 70 * (n + l + s) } } function createNoise3D(t = Math.random) { const e = buildPermutationTable(t), o = new Float64Array(e).map((t => grad3[t % 12 * 3])), r = new Float64Array(e).map((t => grad3[t % 12 * 3 + 1])), a = new Float64Array(e).map((t => grad3[t % 12 * 3 + 2])); return function (t, n, l) { let s, i, c, f; const G = (t + n + l) * F3, u = fastFloor(t + G), F = fastFloor(n + G), d = fastFloor(l + G), m = (u + F + d) * G3, p = t - (u - m), b = n - (F - m), y = l - (d - m); let w, A, T, g, D, N; p >= b ? b >= y ? (w = 1, A = 0, T = 0, g = 1, D = 1, N = 0) : p >= y ? (w = 1, A = 0, T = 0, g = 1, D = 0, N = 1) : (w = 0, A = 0, T = 1, g = 1, D = 0, N = 1) : b < y ? (w = 0, A = 0, T = 1, g = 0, D = 1, N = 1) : p < y ? (w = 0, A = 1, T = 0, g = 0, D = 1, N = 1) : (w = 0, A = 1, T = 0, g = 1, D = 1, N = 0); const x = p - w + G3, P = b - A + G3, M = y - T + G3, h = p - g + 2 * G3, Q = b - D + 2 * G3, R = y - N + 2 * G3, S = p - 1 + .5, q = b - 1 + .5, v = y - 1 + .5, _ = 255 & u, j = 255 & F, O = 255 & d; let U = .6 - p * p - b * b - y * y; if (U < 0) s = 0; else { const t = _ + e[j + e[O]]; U *= U, s = U * U * (o[t] * p + r[t] * b + a[t] * y) } let k = .6 - x * x - P * P - M * M; if (k < 0) i = 0; else { const t = _ + w + e[j + A + e[O + T]]; k *= k, i = k * k * (o[t] * x + r[t] * P + a[t] * M) } let z = .6 - h * h - Q * Q - R * R; if (z < 0) c = 0; else { const t = _ + g + e[j + D + e[O + N]]; z *= z, c = z * z * (o[t] * h + r[t] * Q + a[t] * R) } let B = .6 - S * S - q * q - v * v; if (B < 0) f = 0; else { const t = _ + 1 + e[j + 1 + e[O + 1]]; B *= B, f = B * B * (o[t] * S + r[t] * q + a[t] * v) } return 32 * (s + i + c + f) } } function createNoise4D(t = Math.random) { const e = buildPermutationTable(t), o = new Float64Array(e).map((t => grad4[t % 32 * 4])), r = new Float64Array(e).map((t => grad4[t % 32 * 4 + 1])), a = new Float64Array(e).map((t => grad4[t % 32 * 4 + 2])), n = new Float64Array(e).map((t => grad4[t % 32 * 4 + 3])); return function (t, l, s, i) { let c, f, G, u, F; const d = (t + l + s + i) * F4, m = fastFloor(t + d), p = fastFloor(l + d), b = fastFloor(s + d), y = fastFloor(i + d), w = (m + p + b + y) * G4, A = t - (m - w), T = l - (p - w), g = s - (b - w), D = i - (y - w); let N = 0, x = 0, P = 0, M = 0; A > T ? N++ : x++, A > g ? N++ : P++, A > D ? N++ : M++, T > g ? x++ : P++, T > D ? x++ : M++, g > D ? P++ : M++; const h = N >= 3 ? 1 : 0, Q = x >= 3 ? 1 : 0, R = P >= 3 ? 1 : 0, S = M >= 3 ? 1 : 0, q = N >= 2 ? 1 : 0, v = x >= 2 ? 1 : 0, _ = P >= 2 ? 1 : 0, j = M >= 2 ? 1 : 0, O = N >= 1 ? 1 : 0, U = x >= 1 ? 1 : 0, k = P >= 1 ? 1 : 0, z = M >= 1 ? 1 : 0, B = A - h + G4, C = T - Q + G4, E = g - R + G4, H = D - S + G4, I = A - q + 2 * G4, J = T - v + 2 * G4, K = g - _ + 2 * G4, L = D - j + 2 * G4, V = A - O + 3 * G4, W = T - U + 3 * G4, X = g - k + 3 * G4, Y = D - z + 3 * G4, Z = A - 1 + 4 * G4, $ = T - 1 + 4 * G4, tt = g - 1 + 4 * G4, et = D - 1 + 4 * G4, ot = 255 & m, rt = 255 & p, at = 255 & b, nt = 255 & y; let lt = .6 - A * A - T * T - g * g - D * D; if (lt < 0) c = 0; else { const t = ot + e[rt + e[at + e[nt]]]; lt *= lt, c = lt * lt * (o[t] * A + r[t] * T + a[t] * g + n[t] * D) } let st = .6 - B * B - C * C - E * E - H * H; if (st < 0) f = 0; else { const t = ot + h + e[rt + Q + e[at + R + e[nt + S]]]; st *= st, f = st * st * (o[t] * B + r[t] * C + a[t] * E + n[t] * H) } let it = .6 - I * I - J * J - K * K - L * L; if (it < 0) G = 0; else { const t = ot + q + e[rt + v + e[at + _ + e[nt + j]]]; it *= it, G = it * it * (o[t] * I + r[t] * J + a[t] * K + n[t] * L) } let ct = .6 - V * V - W * W - X * X - Y * Y; if (ct < 0) u = 0; else { const t = ot + O + e[rt + U + e[at + k + e[nt + z]]]; ct *= ct, u = ct * ct * (o[t] * V + r[t] * W + a[t] * X + n[t] * Y) } let ft = .6 - Z * Z - $ * $ - tt * tt - et * et; if (ft < 0) F = 0; else { const t = ot + 1 + e[rt + 1 + e[at + 1 + e[nt + 1]]]; ft *= ft, F = ft * ft * (o[t] * Z + r[t] * $ + a[t] * tt + n[t] * et) } return 27 * (c + f + G + u + F) } } function buildPermutationTable(t) { const e = 512, o = new Uint8Array(e); for (let t = 0; t < 256; t++)o[t] = t; for (let e = 0; e < 255; e++) { const r = e + ~~(t() * (256 - e)), a = o[e]; o[e] = o[r], o[r] = a } for (let t = 256; t < e; t++)o[t] = o[t - 256]; return o } exports.createNoise2D = createNoise2D, exports.createNoise3D = createNoise3D, exports.createNoise4D = createNoise4D, exports.buildPermutationTable = buildPermutationTable;
//# sourceMappingURL=/sm/53accaf434f3c642bcf781f07b2315323b1347475012e84faf8df9649413614b.map